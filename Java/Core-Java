1. WHAT IS JAVA

JAVA IS AN OBJECT ORIENTED PROGRAMMING LANGUAGE, SOME OF ITS BIGGEST FEATURES ARE THAT IT IS PLATFORM INDEPENDENT AND IT
PROVIDES MULTITHREADING. IT IS MAINLY USED FOR APPLICATION PROGRAMMING. JAVA USES COMPILER AND INTERPRETER BOTH, JAVA SOURCE
CODE IS CONVERTED INTO BYTECODE AT COMPILATION TIME, THE INTERPRETER EXECUTES THIS BYTECODE AT RUNTIME AND PRODUCES OUTPUT,
THUS JAVA IS PLATFORM INDEPENDENT.

JAVA IS PORTABLE, THE .JAVA PROGRAM IS CONVERTED INTO THE BYTECODE WHICH IS .CLASS AND THUS CAN BE EXECUTED ANYWHERE
JAVA IS COMPLETELY SECURE, AS JAVA DOES NOT USES EXTERNAL POINTER AND USES BYTECODE, IT HELPS TO MAKE JAVA VERY SECURE


JVM

JAVA VIRTUAL MACHINE ALLOWS THE COMPUTER TO RUN THE PROGRAM, THE JVM ACTS LIKE A RUNTIME ENGINE WHICH CALLS THE MAIN METHOD
PRESENT IN JAVA CODE. THE JAVA CODE IS COMPILED BY THE COMPILER TO TURN INTO BYTECODE WHICH IS THEN CONVERTED INTO MACHINE LANGUAGE
BY JVM WHICH CONSIST OF INTERPRETER AND JIT COMPILER.

JRE

JAVA RUN TIME ENVIRONMENT ENABLES THE JVM TO RUN A JAVA PROGRAM, THE JRE IS A SET OF SOFTWARE TOOLS WHICH ARE USED FOR
DEVELOPING JAVA APPLICATIONS. IT IS USED TO PROVIDE THE RUNTIME ENVIRONMENT, IT IS IMPLEMENTATION OF JVM.

JDK

JAVA DEVELOPMENT KIT IS SOFTWARE DEVELOPMENT ENVIRONMENT USED FOR CREATING JAVA APPLICATION, IT CONSISTS OF JRE AND
DEVELOPMENT TOOLS.

2. MEMORY AREAS ALLOCATED BY JVM

HEAP, STACK, CLASS(METHOD) AREA, PROGRAM COUNTER REGISTER, NATIVE METHOD STACK

CLASS(METHOD) AREA: CLASS AREA STORES PER-CLASS STRUCTURES SUCH AS THE RUNTIME CONSTANT POOL, FIELD, METHOD DATA, AND
THE CODE FOR METHODS.

HEAP: IT IS THE RUNTIME DATA AREA IN WHICH THE MEMORY IS ALLOCATED TO THE OBJECTS

STACK: JAVA STACK STORES FRAMES. IT HOLDS LOCAL VARIABLES AND PARTIAL RESULTS, AND PLAYS A PART IN METHOD INVOCATION AND RETURN.
EACH THREAD HAS A PRIVATE JVM STACK, CREATED AT THE SAME TIME AS THE THREAD. A NEW FRAME IS CREATED EACH TIME A METHOD IS
INVOKED. A FRAME IS DESTROYED WHEN ITS METHOD INVOCATION COMPLETES.

PROGRAM COUNTER REGISTER: PC (PROGRAM COUNTER) REGISTER CONTAINS THE ADDRESS OF THE JAVA VIRTUAL MACHINE INSTRUCTION
CURRENTLY BEING EXECUTED.

NATIVE METHOD STACK: IT CONTAINS ALL THE NATIVE METHODS USED IN THE APPLICATION.

3. JUST-IN-TIME(JIT) COMPILER: IT IS USED TO IMPROVE THE PERFORMANCE. JIT COMPILES PARTS OF THE BYTECODE THAT HAVE SIMILAR
FUNCTIONALITY AT THE SAME TIME, AND HENCE REDUCES THE AMOUNT OF TIME NEEDED FOR COMPILATION.

4. PLATFORM : A PLATFORM IS THE HARDWARE OR SOFTWARE ENVIRONMENT IN WHICH A PIECE OF SOFTWARE IS EXECUTED.THERE ARE TWO
TYPES OF PLATFORMS, SOFTWARE-BASED AND HARDWARE-BASED. JAVA PROVIDES THE SOFTWARE-BASED PLATFORM.

5. CLASSLOADER : CLASSLOADER IS A SUBSYSTEM OF JVM WHICH IS USED TO LOAD CLASS FILES. WHENEVER WE RUN THE JAVA PROGRAM,
IT IS LOADED FIRST BY THE CLASSLOADER. THERE ARE THREE BUILT-IN CLASSLOADERS IN JAVA.

BOOTSTRAP CLASSLOADER : IT LOADS THE RT.JAR FILE WHICH CONTAINS ALL CLASS FILES OF JAVA STANDARD EDITION LIKE JAVA.LANG
PACKAGE CLASSES, JAVA.NET PACKAGE CLASSES, JAVA.UTIL PACKAGE CLASSES, JAVA.IO PACKAGE CLASSES, JAVA.SQL PACKAGE CLASSES,
ETC.

EXTENSION CLASSLOADER : IT LOADS THE JAR FILES LOCATED INSIDE $JAVA_HOME/JRE/LIB/EXT DIRECTORY.

SYSTEM/APPLICATION CLASSLOADER : IT LOADS THE CLASS FILES FROM THE CLASSPATH. BY DEFAULT, THE CLASSPATH IS SET TO
THE CURRENT DIRECTORY. YOU CAN CHANGE THE CLASSPATH USING "-CP" OR "-CLASSPATH" SWITCH.
IT IS ALSO KNOWN AS APPLICATION CLASSLOADER.

6. IN JAVA WE CAN SAVE A FILE BY EMPTY JAVA NAME EG .JAVA

7. WHAT IF I WRITE STATIC PUBLIC VOID INSTEAD OF PUBLIC STATIC VOID?
   THE PROGRAM COMPILES AND RUNS CORRECTLY BECAUSE THE ORDER OF SPECIFIERS DOESN'T MATTER IN JAVA.

8. DIFFERENT ACCESS SPECIFIERS

WHAT IF I WRITE STATIC PUBLIC VOID INSTEAD OF PUBLIC STATIC VOID?
THE PROGRAM COMPILES AND RUNS CORRECTLY BECAUSE THE ORDER OF SPECIFIERS DOESN'T MATTER IN JAVA.

9. WHAT ARE THE ADVANTAGES OF PACKAGES IN JAVA?
   THERE ARE VARIOUS ADVANTAGES OF DEFINING PACKAGES IN JAVA.

   PACKAGES AVOID THE NAME CLASHES.
   THE PACKAGE PROVIDES EASIER ACCESS CONTROL.
   WE CAN ALSO HAVE THE HIDDEN CLASSES THAT ARE NOT VISIBLE OUTSIDE AND USED BY THE PACKAGE.
   IT IS EASIER TO LOCATE THE RELATED CLASSES.

10.   for(int i=0; 0; i++) THIS WILL GIVE COMPILE ERROR AS 2ND PART DEMANDS A BOOLEAN STATEMENT

11. WHAT IS OBJECT ORIENTED PARADIGM(A WAY OF THINKING ABOUT AND STRUCTURING A PROGRAM'S FUNCTIONALITY)

A PARADIGM BASED ON DEFINING METHODS AND DATA, VARIABLES IN A CLASS THEREFORE MAKING THEM REUSABLE. OBJECTS ARE THE
INSTANCES OF CLASSES, WHICH INTERACTS WITH ONE ANOTHER APPLICATIONS/PROGRAMS,

OBJECT : REAL TIME ENTITY HAVING SOME STATE AND BEHAVIOUR, OBJECT IS INSTANCE OF CLASS, WITH INSTANCE VARIABLE AS THE STATE
OF THE OBJECT AND METHODS AS THE BEHAVIOUR. IT IS CREATED USING A NEW KEYWORD

PROGRAM STATE : SIMILARLY, A COMPUTER PROGRAM STORES DATA IN VARIABLES, WHICH REPRESENT STORAGE LOCATIONS IN THE COMPUTER'S
MEMORY. THE CONTENTS OF THESE MEMORY LOCATIONS, AT ANY GIVEN POINT IN THE PROGRAM'S EXECUTION,
IS CALLED THE PROGRAM'S STATE.

CONSTRUCTOR : THE CONSTRUCTOR CAN BE DEFINED AS THE SPECIAL TYPE OF METHOD THAT IS USED TO INITIALIZE THE STATE OF AN OBJECT.
IT IS INVOKED WHEN THE CLASS IS INSTANTIATED, AND THE MEMORY IS ALLOCATED FOR THE OBJECT.
EVERY TIME, AN OBJECT IS CREATED USING THE NEW KEYWORD, THE DEFAULT CONSTRUCTOR OF THE CLASS IS CALLED.
THE NAME OF THE CONSTRUCTOR MUST BE SIMILAR TO THE CLASS NAME. THE CONSTRUCTOR MUST NOT HAVE AN EXPLICIT RETURN TYPE.
TYPES ARE DEFAULT AND PARAMETERIZED.

THE CONSTRUCTOR IMPLICITLY RETURNS THE CURRENT INSTANCE OF THE CLASS, THE CONSTRUCTORS CAN BE OVERLOADED BY CHANGING
THE NUMBER OF ARGUMENTS ACCEPTED BY THE CONSTRUCTOR OR BY CHANGING THE DATA TYPE OF THE PARAMETERS.
CONSIDER THE FOLLOWING EXAMPLE.

METHOD

USED TO EXPOSE BEHAVIOUR OF OBJECT, MUST HAVE RETURN TYPE, INVOKED EXPLICITLY, MAY OR MAY NOT HAVE SAME CLASS NAME, NOT
PROVIDED BY COMPILER.

WHEN ONLY PARAMETERIZED CONSTRUCTOR IS THERE, NO DEFAULT CONSTRUCTOR IS INSTANTIATED BY COMPILER

12. THE STATIC VARIABLE IS COMMON TO ALL THE OBJECT, THE COMPANY NAME OF EMPLOYEES, COLLEGE NAME OF STUDENTS, ETC.
STATIC VARIABLE GETS MEMORY ONLY ONCE IN THE CLASS AREA AT THE TIME OF CLASS LOADING. USING A STATIC VARIABLE MAKES
YOUR PROGRAM MORE MEMORY EFFICIENT (IT SAVES MEMORY). STATIC VARIABLE BELONGS TO THE CLASS RATHER THAN THE OBJECT.
Static variables are only initialized once, only one Object will be created.

STATIC METHODS, COMMON TO CLASS, NO NEED TO CREATE OBJECT WHILE CALLING THE METHOD IF CALLING IN THE SAME CLASS.

STATIC VS NON STATIC METHODS

STATIC DECLARED WITH STATIC KEYWORD, DOES NOT NEED THE OBJECT TO BE INITIALIZED WHILE CALLING IT IN MAIN, CAN CALL
A STATIC METHOD

NON STATIC(INSTANCE)

NOT DECLARED WITH STATIC KEYWORD, NEED THE OBJECT TO BE INITIALIZED IN MAIN, CAN CALL INSTANCE METHOD.

NO REASON TO MAKE CONSTRUCTOR A STATIC

WE CAN DECLARE STATIC VARIABLES AND METHODS IN AN ABSTRACT METHOD. AS WE KNOW THAT THERE IS NO REQUIREMENT TO MAKE THE OBJECT
TO ACCESS THE STATIC CONTEXT, THEREFORE, WE CAN ACCESS THE STATIC CONTEXT DECLARED INSIDE THE ABSTRACT CLASS BY USING THE
NAME OF THE ABSTRACT CLASS.


13. TYPES OF VARIABLES

INSTANCE VARIABLE = DECLARED INSIDE THE CLASS OUTSIDE THE METHOD
LOCAL VARIABLE = DECLARED INSIDE THE METHOD
STATIC VARIABLE = CANNOT BE DEFINED LOCALLY, DEFINED WITH STATIC KEYWORD

14. THIS KEYWORD

IS A REFERENCE VARIABLE, CAN BE USED TO REFER INSTANCE VARIABLE, INSTANCE METHOD, OR EVEN PASSED INTO CONSTRUCTORS, METHOD

THIS CAN BE USED TO REFER TO THE CURRENT CLASS INSTANCE VARIABLE.
THIS CAN BE USED TO INVOKE CURRENT CLASS METHOD (IMPLICITLY)
THIS() CAN BE USED TO INVOKE THE CURRENT CLASS CONSTRUCTOR.
THIS CAN BE PASSED AS AN ARGUMENT IN THE METHOD CALL.
THIS CAN BE PASSED AS AN ARGUMENT IN THE CONSTRUCTOR CALL.
THIS CAN BE USED TO RETURN THE CURRENT CLASS INSTANCE FROM THE METHOD.
THIS CAN ALSO BE USED TO REFER STATIC VARIABLE

REFERENCE VARIABLE CANNOT BE ASSIGNED ANY VALUE

15. CONSTRUCTOR CHAINING ENABLES US TO CALL ONE CONSTRUCTOR FROM ANOTHER
    class Employee {
    int id,age;
    String name, address;
    public Employee (int age)
    {
        this.age = age;
    }
    public Employee(int id, int age)
    {
        this(age);
        this.id = id;
    }
    public Employee(int id, int age, String name, String address)
    {
        this(id, age);
        this.name = name;
        this.address = address;
    }
    public static void main (String args[])
    {
        Employee emp = new Employee(105, 22, "Vikas", "Delhi");
        System.out.println("ID: "+emp.id+" Name:"+emp.name+" age:"+emp.age+" address: "+emp.address);
    }
    }

16. BENEFITS OF PASSING THIS INTO METHOD RATHER THAN CURRENT CLASS OBJECT
THIS IS FINAL AND CANNOT BE CHANGED BUT CLASS OBJECT IS NOT FINAL AND CAN BE CHANGED

17. INHERITANCE
THE MECHANISM OF OOPS, BY WHICH ONE OBJECT OF CLASS CAN ACQUIRE THE METHODS OF ANOTHER CLASS, IT HELPS IN CODE RE USABILITY
, THE IDEA IN JAVA IS THAT IT ALLOWS ONE CLASSED TO BE BUILT UPON ANOTHER CLASSES. IT IS AN IS A RELATIONSHIP
ALSO CALLED AS PARENT CHILD RELATIONSHIP

SINGLE-LEVEL INHERITANCE
MULTI-LEVEL INHERITANCE
MULTIPLE INHERITANCE(NOT SUPPORTED IN JAVA DUE TO AMBIGUITY)
HIERARCHICAL INHERITANCE
HYBRID INHERITANCE

ADVANTAGES

CODE RE USABILITY
PROVIDES RUN TIME POLYMORPHISM
PROVIDE METHOD OVERRIDING
PROVIDES DATA HIDING(HIDE THE DATA OF BASE CLASS USING PRIVATE)

TO REDUCE THE COMPLEXITY AND SIMPLIFY THE LANGUAGE, MULTIPLE INHERITANCE IS NOT SUPPORTED IN JAVA.
CONSIDER A SCENARIO WHERE A, B, AND C ARE THREE CLASSES. THE C CLASS INHERITS A AND B CLASSES.
IF A AND B CLASSES HAVE THE SAME METHOD AND YOU CALL IT FROM CHILD CLASS OBJECT, THERE WILL BE AMBIGUITY TO CALL
THE METHOD OF A OR B CLASS.
SINCE THE COMPILE-TIME ERRORS ARE BETTER THAN RUNTIME ERRORS, JAVA RENDERS COMPILE-TIME ERROR IF YOU INHERIT 2 CLASSES.
SO WHETHER YOU HAVE THE SAME METHOD OR DIFFERENT, THERE WILL BE A COMPILE TIME ERROR.


18. AGGREGATION
AGGREGATION CAN BE DEFINED AS THE RELATIONSHIP BETWEEN TWO CLASSES WHERE THE AGGREGATE CLASS CONTAINS A REFERENCE TO THE
CLASS IT OWNS. AGGREGATION IS BEST DESCRIBED AS A HAS-A RELATIONSHIP. FOR EG THE EMPLOYEE CLASS HAS AN OBJECT OF
THE ADDRESS CLASS AS THE INSTANCE VARIABLE.

HERE EMPLOYEE CLASS IS AGGREGATE AND HAS A ADDRESS

19. COMPOSITION
WHEN AN OBJECT CONTAINS REFERENCE OF A CLASS WITHIN SOME OTHER CLASS AND CANNOT EXIST WITHOUT THE EXISTENCE OF THAT CLASS
FOR EG STUDENTS CLASS CANNOT EXIST WITHOUT CLASS CLASS, SO THERE EXISTS COMPOSITION BETWEEN THEM

20. POINTER ARE NOT USED BECAUSE THEY ARE UNSAFE AND COMPLEX

21. SUPER KEYWORD IS A REFERENCE VARIABLE USED TO REFER IMMEDIATE PARENT CLASS
class Animal { // Superclass (parent)
  public void animalSound() {
    System.out.println("The animal makes a sound");
  }
}

class Dog extends Animal { // Subclass (child)
  public void animalSound() {
    super.animalSound(); // Call the superclass method
    System.out.println("The dog says: bow wow");
  }
}

public class Main {
  public static void main(String args[]) {
    Animal myDog = new Dog(); // Create a Dog object
    myDog.animalSound(); // Call the method on the Dog object
  }
}

SUPER CAN BE USED TO REFER TO THE IMMEDIATE PARENT CLASS INSTANCE VARIABLE.
SUPER CAN BE USED TO INVOKE THE IMMEDIATE PARENT CLASS METHOD.
SUPER() CAN BE USED TO INVOKE IMMEDIATE PARENT CLASS CONSTRUCTOR.

SUPER AND THIS DIFF = SUPER IS USED IN CONTEXT TO PARENT CLASS WHEREAS THIS IS USED IN CONTEXT TO CURRENT CLASS

CAN YOU USE THIS() AND SUPER() BOTH IN A CONSTRUCTOR?
NO, BECAUSE THIS() AND SUPER() MUST BE THE FIRST STATEMENT IN THE CLASS CONSTRUCTOR.

22. METHOD OVERLOADING

SAME METHOD NAME WITH DIFFERENT ARGUMENTS, SUCH AS HAVING DIFFERENT NUMBER OF ARGUMENTS OR DIFFERENT DATATYPE OF ARGUMENTS

METHOD OVERLOADING IS NOT POSSIBLE IN JAVA IN CASE OF HAVING SAME METHOD NAME, SAME ARGUMENTS, SAME TYPE OF ARGUMENTS,
BUT DIFFERENT RETURN TYPE AS IT WOULD CREATE AMBIGUITY.

CAN WE OVERLOAD THE METHODS BY MAKING THEM STATIC?
NO, WE CANNOT OVERLOAD THE METHODS BY JUST APPLYING THE STATIC KEYWORD TO THEM(NUMBER OF PARAMETERS AND TYPES ARE THE SAME).

CAN WE OVERLOAD THE MAIN() METHOD?
YES, WE CAN HAVE ANY NUMBER OF MAIN METHODS IN A JAVA PROGRAM BY USING METHOD OVERLOADING.

23. BY TYPE PROMOTION IS METHOD OVERLOADING, WE MEAN THAT ONE DATA TYPE CAN BE PROMOTED TO ANOTHER IMPLICITLY IF NO EXACT
MATCHING IS FOUND. FOR EG IF THE METHOD ARGUMENT IS INT BUT WE PASS ON THE BYTE IN THE OBJECT.

class OverloadingCalculation3{
  void sum(int a,long b){System.out.println("a method invoked");}
  void sum(long a,int b){System.out.println("b method invoked");}

  public static void main(String args[]){
  OverloadingCalculation3 obj=new OverloadingCalculation3();
  obj.sum(20,20);//now ambiguity
  }
}

AMBIGUITY ABOVE HENCE COMPILE ERROR

23. METHOD OVERRIDING

IF THE BASE CLASS HAS THE SAME METHOD NAME AND ARGUMENTS AS THE DERIVED CLASS IT IS CALLED METHOD OVERRIDING.
METHOD OVERRIDING IS USED FOR RUNTIME POLYMORPHISM. THERE MUST BE INHERITANCE INVOLVED IN METHOD OVERRIDING

class Vehicle{
  //defining a method
  void run(){System.out.println("Vehicle is running");}
}
//Creating a child class
class Bike2 extends Vehicle{
  //defining the same method as in the parent class
  void run(){System.out.println("Bike is running safely");}

  public static void main(String args[]){
  Bike2 obj = new Bike2();//creating object
  obj.run();//calling method
  }
}
Output:

Bike is running safely

24. FINAL

FINAL VARIABLE : CAN'T BE MODIFIED
FINAL METHOD : CAN'T BE OVERRIDE
FINAL CLASS : CAN'T BE INHERITED

CAN WE INITIALIZE THE FINAL BLANK VARIABLE?
YES, IF IT IS NOT STATIC, WE CAN INITIALIZE IT IN THE CONSTRUCTOR. IF IT IS STATIC BLANK FINAL VARIABLE,
IT CAN BE INITIALIZED ONLY IN THE STATIC BLOCK.

CAN YOU DECLARE THE MAIN METHOD AS FINAL?
YES, WE CAN DECLARE THE MAIN METHOD AS PUBLIC STATIC FINAL VOID MAIN(STRING[] ARGS){}.

class Base
{
    protected final void getInfo()
    {
        System.out.println("method of Base class");
    }
}

public class Derived extends Base
{
    protected final void getInfo()
    {
        System.out.println("method of Derived class");
    }
    public static void main(String[] args)
    {
        Base obj = new Base();
        obj.getInfo();
    }
}
Output

	Derived.java:11: error: getInfo() in Derived cannot override getInfo() in Base
    protected final void getInfo()
                         ^
  overridden method is final
1 error

IF YOU DECLARE CONSTRUCTOR AS FINAL COMPILER WILL THROW COMPILE TIME ERROR

INTERFACE CANNOT BE DECLARED AS FINAL AS THEY MUST BE IMPLEMENTED

THE MAIN DIFFERENCE BETWEEN THE FINAL METHOD AND ABSTRACT METHOD IS THAT THE ABSTRACT METHOD CANNOT BE FINAL AS WE
NEED TO OVERRIDE THEM IN THE SUBCLASS TO GIVE ITS DEFINITION.

25. COMPILE TIME / RUN TIME DIFFERENCE

COMPILE TIME = RESOLVED AT COMPILE TIME, EG OVERLOADING, FASTER, STATIC/EARLY BINDING
RUN TIME = RESOLVED AT RUN TIME, EG OVERRIDING, SLOWER, LATE/DYNAMIC BINDING

RUN TIME POLYMORPHISM = CALL TO AN OVERRIDEN METHOD IS RESOLVED AT RUN TIME. METHODS CAN BE OVERRIDEN BUT NOT DATA MEMBERS

26. ABSTRACTION = PROCESS OF HIDING THE IMPLEMENTATION AND SHOWING ONLY FUNCTIONALITY

FOR EG = INTERFACES AND ABSTRACT CLASSES

ABSTRACT METHODS CANNOT HAVE BODY AND MUST BE DEFINED IN AN ABSTRACT CLASS

CAN YOU USE ABSTRACT AND FINAL BOTH WITH A METHOD?
NO, BECAUSE WE NEED TO OVERRIDE THE ABSTRACT METHOD TO PROVIDE ITS IMPLEMENTATION, WHEREAS WE CAN'T OVERRIDE THE FINAL METHOD.

IS IT POSSIBLE TO INSTANTIATE THE ABSTRACT CLASS?
NO, THE ABSTRACT CLASS CAN NEVER BE INSTANTIATED EVEN IF IT CONTAINS A CONSTRUCTOR AND ALL OF ITS METHODS ARE IMPLEMENTED.

INTERFACE : CLASS USED TO ACHIEVE ABSTRACTION, IT CAN HAVE ABSTRACT, STATIC OR DEFAULT METHODS(SINCE JAVA 8)

ABSTRACT METHOD : CAN BE OVERRIDEN BUT CAN'T BE DEFINED IN INTERFACE
DEFAULT METHOD : CAN BE OVERRIDEN AND ALSO CAN BE DEFINED IN INTERFACE
STATIC METHOD : CANNOT BE OVERRIDEN(ONLY WAY TO ACCESS THEM IS BY REFERENCING USING INTERFACE = INTERFACENAME.METHOD)
CAN BE DEFINED IN STATIC METHOD


THE DIFFERENCE BETWEEN ABSTRACT CLASS AND INTERFACE IS NORMAL METHODS ARE ABSTRACT BY NATURE IN INTERFACE WHERE AS
IN ABSTRACT CLASS YOU CAN DEFINE A METHOD, THE ABSTRACT METHODS ARE DEFINED WITH ABSTRACT KEYWORD IN ABSTRACT CLASSES

ABSTRACT METHODS(NORMAL IN INTERFACE) IN BOTH MUST BE IMPLEMENTED

ABSTRACT CLASSES ARE EXTENDED WHEREAS INTERFACES ARE IMPLEMENTED

IMPLEMENTS MEANS YOU ARE USING THE ELEMENTS OF A JAVA INTERFACE IN YOUR CLASS. EXTENDS MEANS THAT YOU ARE CREATING A
SUBCLASS OF THE BASE CLASS YOU ARE EXTENDING.

27. A CLASS CAN BE MADE READ-ONLY BY MAKING ALL OF THE FIELDS PRIVATE. THE READ-ONLY CLASS WILL HAVE ONLY GETTER METHODS
 WHICH RETURN THE PRIVATE PROPERTY OF THE CLASS TO THE MAIN METHOD. WE CANNOT MODIFY THIS PROPERTY BECAUSE THERE IS NO
 SETTER METHOD AVAILABLE IN THE CLASS. CONSIDER THE FOLLOWING EXAMPLE.

 public class Student{
 //private data member
 private String college="AKG";
 //getter method for college
 public String getCollege(){
 return college;
 }
 }

A CLASS CAN BE MADE WRITE-ONLY BY MAKING ALL OF THE FIELDS PRIVATE. THE WRITE-ONLY CLASS WILL HAVE ONLY SETTER METHODS
WHICH SET THE VALUE PASSED FROM THE MAIN METHOD TO THE PRIVATE FIELDS. WE CANNOT READ THE PROPERTIES OF THE CLASS
BECAUSE THERE IS NO GETTER METHOD IN THIS CLASS. CONSIDER THE FOLLOWING EXAMPLE.

public class Student{
//private data member
private String college;
//getter method for college
public void setCollege(String college){
this.college=college;
}
}

What do you mean by encapsulation?
Encapsulation is a way to restrict the direct access to some components of an object, so users cannot access state values for
all of the variables of a particular object. Encapsulation can be used to hide both data members and data functions or methods
associated with an instantiated class or object.

We can also say that encapsulation is building of class via the variables and methods working together.

ADVANTAGES OF ENCAPSULATION:
DATA CAN BE MADE READ/WRITE ONLY, DATA HIDING CAN BE DONE, MODIFY LOGIC WHILE STORING DATA SUCH AS USING LOGIC IN SETTER
, EASY TO UNIT TEST.

A PACKAGE IS A GROUP OF SIMILAR TYPE OF CLASSES, INTERFACES, AND SUB-PACKAGES. IT PROVIDES ACCESS PROTECTION AND REMOVES
NAMING COLLISION. THE PACKAGES IN JAVA CAN BE CATEGORIZED INTO TWO FORMS, INBUILT PACKAGE, AND USER-DEFINED PACKAGE.

28. DO I NEED TO IMPORT JAVA.LANG PACKAGE ANY TIME? WHY?
    NO. IT IS BY DEFAULT LOADED INTERNALLY BY THE JVM.

29. BY STATIC IMPORT, WE CAN ACCESS THE STATIC MEMBERS OF A CLASS DIRECTLY, AND THERE IS NO TO QUALIFY IT WITH THE CLASS NAME.

30. CHECKED EXCEPTION: CHECKED EXCEPTIONS ARE THE ONE WHICH ARE CHECKED AT COMPILE-TIME. FOR EXAMPLE, SQLEXCEPTION,
CLASSNOTFOUNDEXCEPTION, ETC. Handled with throws
For example, consider the following Java program that opens the file at location “C:\test\a.txt” and prints the first three lines of it.
The program doesn’t compile, because the function main() uses FileReader() and FileReader() throws a checked exception FileNotFoundException.
It also uses readLine() and close() methods, and these methods also throw checked exception IOException

UNCHECKED EXCEPTION: UNCHECKED EXCEPTIONS ARE THE ONE WHICH ARE HANDLED AT RUNTIME BECAUSE THEY CAN NOT BE CHECKED
AT COMPILE-TIME. FOR EXAMPLE, ARITHMATICEXCEPTION, NULLPOINTEREXCEPTION, ARRAYINDEXOUTOFBOUNDSEXCEPTION, ETC.
ERROR: ERROR CAUSE THE PROGRAM TO EXIT SINCE THEY ARE NOT RECOVERABLE. FOR EXAMPLE, OUTOFMEMORYERROR, ASSERTIONERROR, ETC.

IT IS NOT NECESSARY THAT EACH TRY BLOCK MUST BE FOLLOWED BY A CATCH BLOCK. IT SHOULD BE FOLLOWED BY EITHER A CATCH BLOCK
OR A FINALLY BLOCK.

31. STRING POOL = MEMORY RESERVED IN HEAP THAT CAN BE USED TO STORE STRING, WHENEVER WE CREATE STRING LITERAL
IT CHECK IN STRING POOL IF IT ALREADY EXISTS, A REFERENCE TO POOLED INSTANCE IS RETURNED. IT SAVES MEMORY
BY AVOIDING DUPLICACY

THE SIMPLE MEANING OF IMMUTABLE IS UNMODIFIABLE OR UNCHANGEABLE. IN JAVA, STRING IS IMMUTABLE, I.E.,
ONCE STRING OBJECT HAS BEEN CREATED, ITS VALUE CAN'T BE CHANGED.

class Testimmutablestring{
 public static void main(String args[]){
   String s="Sachin";
   s.concat(" Tendulkar");//concat() method appends the string at the end
   System.out.println(s);//will print Sachin because strings are immutable objects
 }
}

WHY STRINGS ARE IM MUTABLE, BECAUSE STRING POOL USES REFERENCE, SUPPOSE S1 IS DEFINED AND S2 AND S3 HAVE SAME VALUE
AND STRING POOL RETURN S1 TO REFER, NOW IF S1 WAS CHANGED S2 AND S3 WOULD ALSO BE CHANGED SO STRING ARE IM MUTABLE

String s=new String("Welcome");//creates two objects and one reference variable
IN SUCH CASE, JVM WILL CREATE A NEW STRING OBJECT IN NORMAL (NON-POOL) HEAP MEMORY, AND THE LITERAL "WELCOME" WILL BE
PLACED IN THE CONSTANT STRING POOL. THE VARIABLE S WILL REFER TO THE OBJECT IN A HEAP (NON-POOL).

public class Test
{
    public static void main (String args[])
    {
        String s1 = "Sharma is a good player";
        String s2 = new String("Sharma is a good player");
        s2 = s2.intern();
        System.out.println(s1 ==s2);
    }
}

THE ABOVE IS TRUE BECAUSE INTERN RETURNS THE MEMORY REFERENCE FROM STRING POOL

STRING BUFFER DIFF STRING = STRING IS IMMUTABLE, STRING BUFFER IS MUTABLE, CONCAT STRING IS SLOW AS EVERYTIME IT WILL
HAVE TO MAKE A NEW STRING LITERAL, STRING BUFFER CONCAT IS FAST

STRING BUFFER IS SYNCHORNIZED, MEANS TWO THREADS CAN'T CALL THE SAME METHOD HENCE IT IS THREAD SAFE,
STRING BUILDER IS NOT SYNCHRONIZED, MEANS TWO THREADS CAN CALL THE SAME METHOD HENCE IT IS NOT THREAD SAFE
STRING BUFFER IS LESS EFFICIENT, STRING BUILDER IS MORE

THE TOSTRING() METHOD RETURNS THE STRING REPRESENTATION OF AN OBJECT. IF YOU PRINT ANY OBJECT, JAVA COMPILER INTERNALLY
INVOKES THE TOSTRING() METHOD ON THE OBJECT. SO OVERRIDING THE TOSTRING() METHOD, RETURNS THE DESIRED OUTPUT,
IT CAN BE THE STATE OF AN OBJECT, ETC. DEPENDING UPON YOUR IMPLEMENTATION. BY OVERRIDING THE TOSTRING() METHOD OF
THE OBJECT CLASS, WE CAN RETURN THE VALUES OF THE OBJECT, SO WE DON'T NEED TO WRITE MUCH CODE. CONSIDER THE FOLLOWING EXAMPLE.

STRING STAYS IN THE STRING POOL UNTIL THE GARBAGE IS COLLECTED. IF WE STORE THE PASSWORD INTO A STRING, IT STAYS IN THE
MEMORY FOR A LONGER PERIOD, AND ANYONE HAVING THE MEMORY-DUMP CAN EXTRACT THE PASSWORD AS CLEAR TEXT. ON THE OTHER HAND,
USING CHARARRAY ALLOWS US TO SET IT TO BLANK WHENEVER WE ARE DONE WITH THE PASSWORD. IT AVOIDS THE SECURITY THREAT WITH
THE STRING BY ENABLING US TO CONTROL THE MEMORY.

32. JAVA INNER CLASSES

NESTED CLASSES REPRESENT A SPECIAL TYPE OF RELATIONSHIP THAT IS IT CAN ACCESS ALL THE MEMBERS (DATA MEMBERS AND METHODS) OF
THE OUTER CLASS INCLUDING PRIVATE.

NESTED CLASSES ARE USED TO DEVELOP A MORE READABLE AND MAINTAINABLE CODE BECAUSE IT LOGICALLY GROUPS CLASSES AND
INTERFACES IN ONE PLACE ONLY. CODE OPTIMIZATION: IT REQUIRES LESS CODE TO WRITE.

THE NESTED CLASS CAN BE DEFINED AS THE CLASS WHICH IS DEFINED INSIDE ANOTHER CLASS OR INTERFACE. WE USE THE NESTED CLASS
TO LOGICALLY GROUP CLASSES AND INTERFACES IN ONE PLACE SO THAT IT CAN BE MORE READABLE AND MAINTAINABLE. A NESTED CLASS
CAN ACCESS ALL THE DATA MEMBERS OF THE OUTER CLASS INCLUDING PRIVATE DATA MEMBERS AND METHODS.

INNER CLASSES TYPES

MEMBER INNER CLASS : CREATED OUTSIDE METHOD, INSIDE CLASS
LOCAL INNER CLASS : INSIDE METHOD
ANONYMOUS INNER CLASS : CREATED FOR IMPLEMENTING AN INTERFACE OR ABSTRACT CLASS, EG INTERFACENAME IF = NEW INTERFACENAME(){
abstract methods:
};

INNER CLASSES ARE NON-STATIC NESTED CLASSES. IN OTHER WORDS, WE CAN SAY THAT INNER CLASSES ARE THE PART OF NESTED CLASSES.

INTERFACE WITHIN INTERFACE OR CLASS WITH INTERFACE ARE STATIC IMPLICITLY

34. GARBAGE COLLECTION

THE PROCESS OF REMOVING UNUSED OBJECTS FROM THE MEMORY TO FREE UP SPACE FOR JVM TO WORK, FOR EG VARIABLE WHICH HAS BEEN
DEFINED BUT NOT INITIALIZED.

JVM CONTROLS GARBAGE COLLECTION WHEN MEMORY IS RUNNING LOW.

FINALIZE METHOD = IT IS THE METHOD WHICH IS ALWAYS CALLED BY THE GARBAGE COLLECTOR BEFORE DESTROYING THE OBJECT,
IT IS USED TO CLOSE THE RESOURCES WHICH WERE USED BY THE OBJECT, EG DB CONNECTION, NETWORK RESOURCE ETC.

GARBAGE COLLECTOR THREAD = DAEMON THREAD

FINAL IS KEYWORD, FINALLY IS BLOCK, FINALIZE IS A METHOD

HOW WILL YOU INVOKE ANY EXTERNAL PROCESS IN JAVA?
BY RUNTIME.GETRUNTIME().EXEC(?) METHOD. CONSIDER THE FOLLOWING EXAMPLE.

PUBLIC CLASS RUNTIME1{
 PUBLIC STATIC VOID MAIN(STRING ARGS[])THROWS EXCEPTION{
  RUNTIME.GETRUNTIME().EXEC("NOTEPAD");//WILL OPEN A NEW NOTEPAD
 }
}

35. IO STREAM = STREAM IS A SEQUENCE OF DATA THAT FLOWS FROM SOURCE TO DESTINATION, IN JAVA 3 TYPES OF STREAM ARE CREATED
FOR US AUTOMATICALLY : SYSTEM.OUT, SYSTEM.IN, SYSTEM.ERR

READER/WRITER CLASS IS CHARACTER ORIENTED, I/O STREAM IS BYTE ORIENTED
THE BYTE STREAM CLASS USED TO PERFORM I/O OF 8 BYTES WHEREAS CHARACTER STREAM IS USED TO PERFORM I/O FOR 16 BIT UNICODE
SYSTEM
MOST COMMONLY USED BYTE STREAM CLASSES ARE FILE INPUT STREAM AND F O STREAM AND MOST COMMONLY USED
CLASS CHARACTER STREAM CLASS IS F READER AND F WRITER

FILE OUTPUT STREAM = CLASS USED TO WRITE DATA INTO A FILE, IF WE HAVE SOME PRIMITIVE DATA WE CAN USE THIS CLASS,
WE CAN USE THIS FOR BOTH BYTE ORIENTED AND CHARACTER ORIENTED PURPOSE HOWEVER IT IS RECOMMEND TO USE FILE WRITER STREAM
FOR CHARACTER ORIENTED DATA.

FILE INPUT STREAM = OBTAINS INPUT BYTES FROM FILE, WE CAN USE THIS TO READ ANY FORM OF DATA BE IT BYTE ORIENTED
OR CHARACTER ORIENTED HOWEVER IT IS RECOMMEND TO USE FILE READER STREAM FOR CHARACTER ORIENTED DATA

BUFFERED OUTPUT STREAM USES BUFFER TO STORE DATA MAKING PERFORMANCE FASTER WHEREAS BUFFERED INPUT STREAM INTERNALLY USES
BUFFER MECHANISM TO MAKE PERFORMANCE FASTER

FILTER STREAM CLASSES ARE USED TO ADD ADDITIONAL FUNCTIONALITY TO OTHER STREAM CLASSES, IT READS THE DATA, FILTERS
AND PASSES THE FILTERED DATA TO THE CALLER

36. SERIALIZATION = THE PROCESS OF CONVERTING A JAVA CODE OBJECT INTO A BYTESTREAM, IT ALLOWS US TO SEND THE DATA
OVER TO A NETWORK, OR SAVE IT AS FILE OR DB, THE OBJECT CAN BE RECREATED FROM ITS SERIALIZED STATE
USING DESERIALIZATION. A CLASS CAN BECOME SERIALIZABLE BY IMPLEMENTING THE SERIALIZABLE INTERFACE.

IF YOU DEFINE ANY DATA MEMBER AS TRANSIENT, IT WILL NOT BE SERIALIZED. BY DETERMINING TRANSIENT KEYWORD, THE VALUE OF
VARIABLE NEED NOT PERSIST WHEN IT IS RESTORED.

THE EXTERNALIZABLE INTERFACE IS USED TO WRITE THE STATE OF AN OBJECT INTO A BYTE STREAM IN A COMPRESSED FORMAT.
IT IS NOT A MARKER INTERFACE.

SERIALIZABLE DOES NOT HAVE ANY METHOD(IT IS MARKER INTERFACE) BUT EXTERNALIZABLE HAS 2(READ EXTERNAL, WRITE EXTERNAL)
SERIALIZABLE IS EASY TO IMPLEMENT BUT COSTS HIGHER WHEREAS EXTERNALIZABLE HAS BETTER PERFORMANCE
NO CONSTRUCTOR IS CALLED FOR SERIALIZABLE WHEREAS PUBLIC DEFAULT CONTRUCTOR IS CALLED FOR EXTERNALIZABLE
SERIALIZABLE, IN THIS DEVELOPER HAS NO CONTROL ONLY JVM CONTROLS BUT IN EXTERNALIZABLE DEVELOPER HAS FULL CONTROL
SO IT CAN DEFINE USING REQUIREMENTS AND JVM DOESN'T CONTROL THIS

37. JAVA SOCKET PROGRAMMING = THIS TYPE OF PROGRAMMING IS USED TO COMMUNICATE BETWEEN THE APPLICATIONS RUNNING ON DIFFERENT
JRE. THE CLIENT IN SOCKET PROGRAMMING MUST KNOW IP ADDRESS, PORT NUMBER.

SOCKET IS SIMPLY AN ENDPOINT FOR COMMUNICATIONS BETWEEN TWO MACHINES

FULL SERVER SOCKET PROCESS

SERVER OBJECT IS INSTANTIATED BY SERVER HAVING THE PORT NUMBER TO WHICH CONNECTION WILL BE MADE, AFTER THIS
SERVER INVOKES THE ACCEPT METHOD OF SERVER OBJECT AND WAITS TILL CONNECTION IS MADE, MEANWHILE SERVER IS WAITING SOCKET
IS CREATED BY CLIENT BY INSTANTIATING SOCKET CLASS, THE SOCKET CLASS ACCEPTS THE PORT NUMBER AND SERVER NAME, ONCE
CONNECTION IS MADE THE SERVER CAN REFERENCE THE SOCKET OBJECT FROM CLIENT

REFLECTION

MODIFYING BEHAVIOUR OF A CLASS AT RUNTIME, PROVIDES VARIOUS METHODS THAT CAN BE USED TO GET METADATA

38. THE NEWINSTANCE() METHOD OF THE CLASS CLASS IS USED TO INVOKE THE CONSTRUCTOR AT RUNTIME. IN THIS PROGRAM,
THE INSTANCE OF THE SIMPLE CLASS IS CREATED.

  Class c=Class.forName("Simple");
  Simple s=(Simple)c.newInstance();

39. WRAPPER CLASSES

WRAPPER CLASSES ALLOWS PRIMITIVE DATA TYPES TO BE ACCESSED AS AN OBJECT. THESE ARE PREDEFINED CLASSES IN JAVA WHICH ALLOWS
THE CONVERSION OF PRIMITIVE DATATYPE TO OBJECT AND VICEVERSA.

AUTOBOXING AND UNBOXING = AUTOBOXING IS THE PROCESS OF CONVERSION OF THE PRIMITIVE DATA TO JAVA OBJECT, EG INT TO INTEGER
UNBOXING IS THE PROCESS OF CONVERSION OF OBJECT TO PRIMITIVE DATA, EG INTEGER TO INT, BOTH OCCUR AUTOMATICALLY HOWEVER
WE CAN ALSO MANUALLY USE THEM

40. SINGLETON CLASS IS THE CLASS WHICH CAN NOT BE INSTANTIATED MORE THAN ONCE. TO MAKE A CLASS SINGLETON, WE EITHER MAKE ITS
CONSTRUCTOR PRIVATE OR USE THE STATIC GETINSTANCE METHOD. CONSIDER THE FOLLOWING EXAMPLE.

class Singleton{
    private static Singleton single_instance = null;
    int i;
     private Singleton ()
     {
         i=90;
     }
     public static Singleton getInstance()
     {
         if(single_instance == null)
         {
             single_instance = new Singleton();
         }
         return single_instance;
     }
}
public class Main
{
    public static void main (String args[])
    {
        Singleton first = Singleton.getInstance();
        System.out.println("First instance integer value:"+first.i);
        first.i=first.i+90;
        Singleton second = Singleton.getInstance();
        System.out.println("Second instance integer value:"+second.i);
    }
}


41. A LOCALE OBJECT REPRESENTS A SPECIFIC GEOGRAPHICAL, POLITICAL, OR CULTURAL REGION. THIS OBJECT CAN BE USED TO GET THE
LOCALE-SPECIFIC INFORMATION SUCH AS COUNTRY NAME, LANGUAGE, VARIANT, ETC.

42. JAVABEAN IS A REUSABLE SOFTWARE COMPONENT WRITTEN IN THE JAVA PROGRAMMING LANGUAGE, DESIGNED TO BE MANIPULATED VISUALLY
BY A SOFTWARE DEVELOPMENT ENVIRONMENT, LIKE JBUILDER OR VISUALAGE FOR JAVA. T. A JAVABEAN ENCAPSULATES MANY OBJECTS INTO
ONE OBJECT SO THAT WE CAN ACCESS THIS OBJECT FROM MULTIPLE PLACES. MOREOVER, IT PROVIDES THE EASY MAINTENANCE.

43. AN ERROR IS A SUBCLASS OF THROWABLE THAT INDICATES SERIOUS PROBLEMS THAT A REASONABLE APPLICATION SHOULD NOT TRY TO CATCH.
 MOST SUCH ERRORS ARE ABNORMAL CONDITIONS. THE THREADDEATH ERROR, THOUGH A "NORMAL" CONDITION, IS ALSO A SUBCLASS OF ERROR
 BECAUSE MOST APPLICATIONS SHOULD NOT TRY TO CATCH IT.

44. THREAD = A THREAD IS A LIGHTWEIGHT SUB PROCESS, IT IS THE SMALLEST UNIT OF PROCESSING.
THREADS ARE INDEPENDENT, IF THERE OCCURS AN EXCEPTION IN THREAD THEN IT DOES NOT AFFECT OTHER THREAD
WE CAN CREATE A THREAD BY EXTENDING THE THREAD CLASS OR BY IMPLEMENTING THE RUNNABLE INTERFACE
WE CAN DIRECTLY CREATE THREAD TOO BY INSTANTIATING A NEW THREAD USING NEW KEYWORD

PROCESS BASED MULTITASKING IS MULTIPROCESSING AND THREAD BASED MULTITASKING IN MULTITHREADING

THREAD LIFECYCLE

NEW -> RUNNABLE -> RUNNING -> NON-RUNNABLE(BLOCKED) -> TERMINATED

45. POLYMORPHISM MEANS HAVING MANY FORMS.

THREADSAFE

As we know Java has a feature, Multithreading, which is a process of running multiple threads simultaneously. When multiple
threads are working on the same data, and the value of our data is changing(meaning it is mutable), that scenario is not
thread-safe and we will get inconsistent results. When a thread is already working on an object and preventing another
thread on working on the same object, this process is called Thread-Safety.

What is Recursion?
The process in which a function calls itself directly or indirectly is called recursion and the corresponding
function is called a recursive function.

Properties of Recursion:
Performing the same operations multiple times with different inputs.
In every step, we try smaller inputs to make the problem smaller.
A base condition is needed to stop the recursion otherwise infinite loop will occur.
What is Backtracking?
Backtracking is an algorithmic technique for solving problems recursively by trying to build a solution incrementally,
one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point in time
(by time, here, is referred to the time elapsed till reaching any level of the search tree).

Backtracking can be defined as a general algorithmic technique that considers searching every possible combination
in order to solve a computational problem.

Recursion does not always need backtracking, while backtracking always require recursion
recursion is top down approach

Dynamic programming has two types
Top Down or Memoization, in which we store value and when it is repeated we simply return rather than calling recursion
from it again
Bottom up
In this we solve sub problems to solve the bigger problems

Parent of all Classes - Object


Can we overload two methods with same name same parameters but different return type

No we cannot because during the time of compilation, compiler only considers name and parameters and not the return type
hence it throws compile time error.

Are there 8 primitive data types in Java?
Primitive data types - includes byte , short , int , long , float , double , boolean and char.

Why are wrapper classes needed in Java? Wrapper classes are fundamental in Java because they help a Java program be completely object-oriented.
The primitive data types in java are not objects, by default. They need to be converted into objects using wrapper classes.

Advantages of using a switch statement over a traditional if-else cascade. While it is true that the same functionalities of the switch statement can
also be implemented using an if-else cascade, the switch statement allows us in certain situations to write a more clear, compact and readable code.

Exception Tree in Java

                                            Object
                                               |
                                            Throwable
                                               |
                             Error                              Exception
                                |
                         Syntax Error, RunTimeError, Logical Error


                        Checked Exceptions = SQLException, IO Exception, Broken Barrier Exception
                        Unchecked Exceptions = Null Pointer Exception, Arithmetic Exception

Error class is java.type.lang.error
Throw vs Throws

Throw is used to explicitly throw an exception where as throws is used to declare exception
Checked exception can not be propagated using throw where as it can be via throws.
Throw is used within method whereas throws with the method
You can only throw one exception where as you can use throws to declare more than one exceptions.

Java do not use pointers because using pointer the memory area can be directly accessed, which is a security issue.
pointers need so memory spaces at the runtime. to reduce the usage of memory spaces java does not support pointers.
and also pointers take more time at the run time.


default method is found in interface

System.out = output
System.err = error output
System.in = input

An enum is a special "class" that represents a group of constants (unchangeable variables, like final variables).
To create an enum, use the enum keyword (instead of class or interface), and separate the constants with a comma.
Note that they should be in uppercase letters:

Data abstraction is the process of hiding certain details and showing only essential information to the user.
Abstraction can be achieved with either abstract classes or interfaces.

Encapsulation in Java refers to integrating data (variables) and code (methods) into a single unit.
In encapsulation, a class's variables are hidden from other classes and can only be accessed by the methods of
the class in which they are found.

In Java, polymorphism refers to the ability of a class to provide different implementations of a method,
depending on the type of object that is passed to the method. To put it simply, polymorphism in Java allows
us to perform the same action in many different ways.

Inheritance in Java is a mechanism in which one object acquires all the properties and behaviors of a parent object.


There are two types of methods in Java: Predefined Method. User-defined Method.

Object - real time entity of class
Class - blueprint which has all the objects

A static variable means that this variable belongs to the entire class and not any particular instance. Furthermore, inside a method
is "local scope" to that method. Thus, in java, local scope and global (or class) scope don't mix.So, declare your static variables
as part of the class which is the proper scope since they are "class variables".

String Pool

String pool is memory area in heap for string

Suppose you initialize a String i.e -> String s1 = "Hello", then s1 -> hello memory reference in string pool
and now if s2 = "Hello" then again s2 -> hello memory reference in string pool
but if we do s3 = new String("Hi") this will create object in heap with Hi and also in string pool with Hi(however this hi would be referred
by some variable from jvm.

int is a primitive data type and takes 32 bits(4 bytes) to store. On other hand Integer is an object which takes
128 bits (16 bytes) to store its int value

String Literals in Java
A string literal in Java is basically a sequence of characters from the source character set used by Java programmers
to populate string objects or to display text to a user. These characters could be anything like letters,
numbers or symbols which are enclosed within two quotation marks

if s1 = "java"
s2 = "java"
s3 = new String("java")
s4 = new String("java")

above three object will be created, first in the string pool, then s2 will refer to same string pool
third and fourth will create object in heap but will refer to string pool where java is already
present


What is System.out.println
In Java, System.out.println() is a statement which prints the argument passed to it. The println() method display
results on the monitor. Usually, a method is invoked by objectname.methodname()
System is a final class in java.lang package, out is a static final variable in System class of PrintStream and
println is a method in PrintStream

How toString gets activated automatically?
It is activated inside the printstreams method such as println.

Is int 9 and int 09 same
When you precede a number with 0 ("09" rather than "9"), then Java (and C and many other languages) interpret the
number to be in octal - base-8. "09" is not a valid number in octal -any single digit can be a maximum of "7"
(since in octal, numbers go from 0.. 7).

Why we need wrapper
Firstly the question that hits the programmers is when we have primitive data types then why does there arise a
need for the concept of wrapper classes in java. It is because of the additional features being there in the
Wrapper class over the primitive data types when it comes to usage. These methods include primarily methods like
valueOf(), parseInt(), toString(), and many more.

JAR files allow us to package multiple files in order to use it as a library, plugin, or any kind of application.
On the other hand, WAR files are used only for web applications. The structure of the archives is also different

Tight Coupling
In general, Tight coupling means the two classes often change together. In other words, if A knows more than it
should about the way in which B was implemented, then A and B are tightly coupled.

Loose coupling
In simple words, loose coupling means they are mostly independent. If the only knowledge that class A has
about class B, is what class B has exposed through its interface, then class A and class B are said to be
loosely coupled. In order to over come from the problems of tight coupling between objects, spring framework
uses dependency injection mechanism with the help of POJO/POJI model and through dependency injection its
possible to achieve loose coupling.

eg class A implements interface I and class B implements interface I, then A & B are loosely coupled

Loose Coupling is better as problems can arise on changing some class in that.

Why not to use StringBuilder in hashmap
StringBuilder/Buffer do not override hashCode and equals. This means each instance of the object should be a
unique hash code and the value or state of it does not matter. You should use the String for a key.
StringBuilder/Buffer is also mutable which is generally not a good idea to use as a key for a HashMap since
storing the value under it can cause the value to be inaccessible after modification.


What is Byte Stream in Java?
Byte streams are used to perform input and output of 8-bit bytes. They are used to read bytes
from the input stream and write bytes to the output stream. Mostly, they are used to read or
write raw binary data.

Serialization
It is the process of converting an object into sequence of bytes.
Deserialization
The process of converting sequence of bytes to object.

Why java does not use pointers?
Java do not use pointers because using pointer the memory area can be directly accessed, which is a
security issue. pointers need so memory spaces at the runtime. to reduce the usage of memory spaces
java does not support pointers. and also pointers take more time at the run time.

Can we overload static methods?
Yes, we can overload static methods, we can have two or more static methods with the same name
but with different parameters.

Can we override static methods?
NO, we can't override static methods since method overriding relies on dynamic binding at runtime, but
static methods are bonded at compile time with static binding. As a result, we are unable to override
static methods.


String intern method
The intern() method returns a canonical representation of the string, which means that it returns a reference to the unique instance
of the string in the string pool.

Eg

        String s1 = new String("Hello");
        String s2 = new String("Hello");

        System.out.println(s1 == s2); // false
        s1 = s1.intern();
        s2 = s2.intern();
        System.out.println(s1 == s2); // true

Prevent a class being subclassed in java
Use final, this is the same reason string or wrapper classes are final

Transient in java
Transient is a variables modifier used in serialization. At the time of serialization, if we don’t want to save
value of a particular variable in a file, then we use transient keyword. When JVM comes across transient keyword,
it ignores original value of the variable and save default value of that variable data type.

Generics in java
Generics means parameterized types. The idea is to allow type (Integer, String, … etc., and user-defined types) to be
a parameter to methods, classes, and interfaces. Using Generics, it is possible to create classes that work with
different data types. An entity such as class, interface, or method that operates on a parameterized type is a
generic entity.

class Parent {
    int a = 10;
}
public class Practice extends Parent {
    int a = 20;
    public static void main(String[] args) {
        Parent parent = new Practice();
        int val = parent.a;
        System.out.println(val);
    }
}

The concept demonstrated in the provided code is called variable hiding or variable shadowing.
In the Practice class, there is an instance variable a with a value of 20, which is declared in the Practice class itself.
However, the Practice class also extends the Parent class, which has its own instance variable a with a value of 10.
In the main method, an object of the Practice class is created and assigned to a variable of type Parent. When accessing
the a variable through the parent reference, it refers to the a variable of the Parent class. This is because variables
in Java are not polymorphic, and the reference type determines which variable is accessed.
Therefore, the output of System.out.println(val); would be 10, as it is accessing the a variable of the Parent class through
the parent reference.

Also in the above remember that parent object cannot call the methods of child object.
Also child object cannot be initiated directly as parent object meaning Practice p = new Parent();
if we typecast Practice p = (Practice) new Parent(); this will result in ClassCastException

The ClassCastException is thrown because the (IMPORTANT PONT) Parent class does not inherit the methods and fields
defined in the Practice class. It is the other way around: the Practice class extends the Parent class, which means
an instance of Practice is also an instance of Parent. However, the reverse is not true. An instance of Parent is
not an instance of Practice

Variable hiding in Java refers to the situation where a subclass declares a variable with the same name as a variable in
its superclass. This causes the variable in the subclass to "hide" the variable in the superclass, leading to different
variables with the same name coexisting at different levels of the class hierarchy.

Variable hiding
class Parent {
    int variable = 10;
}

class Child extends Parent {
    int variable = 20;

    void printVariables() {
        System.out.println("Child variable: " + variable);
        System.out.println("Parent variable: " + super.variable);
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.printVariables();
    }
}

Volatile in java

In Java, the volatile keyword is used to indicate that a variable's value may be modified by multiple threads. It ensures
that when one thread modifies the value of a volatile variable, the change is immediately visible to other threads accessing
the same variable. In other words, it provides a guarantee of visibility and ordering of variable accesses across multiple
threads.

In Java, reflection is a feature that allows you to examine and modify the structure and behavior of classes, interfaces,
fields, methods, and constructors at runtime. It provides a way to introspect the properties and capabilities of objects
and classes, even if the code working with them was not aware of their existence at compile-time.

Can constructor be private
Yes, a constructor in Java can be declared as private. When a constructor is marked as private, it means that it can
only be accessed and invoked from within the same class. It cannot be called by code in other classes, including
subclasses. Can be done in following situations.

Singleton pattern: In the singleton pattern, a class is designed to have only one instance throughout the entire application.
To achieve this, the constructor is made private, preventing other classes from directly creating instances. The class
itself typically provides a public static method that returns the singleton instance.

Utility classes: Utility classes, which typically contain only static methods, are commonly used to provide helper functions
or common operations. Since utility classes are not meant to be instantiated, their constructors are made private to
prevent accidental instantiation.

Factory methods: In certain cases, a class may provide static factory methods that create instances of the class with
specific configurations or based on certain conditions. The constructors of the class can be made private, and the
factory methods handle the instantiation and return the created objects.

Encapsulation : Wrapping of data in a single unit. For eg consider class a single unit then instance variable
name and getName() method and combining them together to get value of name is encapsulation.

In Java, the term "meta space" refers to a memory space used by the Java Virtual Machine (JVM) to store metadata about
loaded classes, methods, and other runtime information. Before Java 8, this memory space was known as the "permanent
generation" (PermGen). However, starting from Java 8, PermGen was replaced with meta space.Meta space is a part of the
native heap and is separate from the Java heap, which is used for storing objects and their instance data. It is
dynamically allocated by the JVM and can grow or shrink based on the application's needs.

How to make any class immutable

public final class Person {
    private final String name;
    private final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

Main difference between wrapper and primitive are = wrapper follow oops principles, primitive can not contain null,
wrapper are used in collection and generics.
}